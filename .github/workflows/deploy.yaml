name: 'Terraform Plan/Apply'

on:
  workflow_dispatch:
    inputs:
      tf_apply:
        description: 'Run Terraform apply?'
        required: false
        type: string
        default: "true"
  push:
    branches:
      - main
      - dev

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  UAMI_ID: ${{ vars.UAMI_ID }}
  ARM_SUBSCRIPTION_ID: "${{ vars.SUB_ID }}"
  ARM_TENANT_ID: "${{ vars.TENANT_ID }}"

jobs:

  build-image:
    environment: main
    name: Image Build
    runs-on: ubuntu-latest
    outputs:
      src_hash: ${{ steps.srchash.outputs.src_hash }}
    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Login to Azure using Federated Credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.UAMI_ID }}
          tenant-id: ${{ vars.TENANT_ID }}
          subscription-id: ${{ vars.SUB_ID }}

      - name: Get ACR access token
        id: acrtoken
        run: |
          TOKEN=$(az acr login --name ${{ vars.ACR_NAME }} --expose-token --query accessToken -o tsv)
          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Docker login to ACR
        uses: docker/login-action@v3
        with:
          registry: "${{ vars.ACR_NAME }}.azurecr.io"
          username: 00000000-0000-0000-0000-000000000000
          password: ${{ steps.acrtoken.outputs.token }}

      - name: Compute src hash for image tag
        id: srchash
        run: |
          set -e
          # prefer git tree hash for src/ when available (deterministic per commit)
          if git rev-parse --verify HEAD:src >/dev/null 2>&1; then
            HASH=$(git rev-parse --verify HEAD:src)
          else
            HASH=$(find src -type f -print0 | sort -z | xargs -0 sha256sum | sha256sum | awk '{print $1}')
          fi
          SHORT=${HASH:0:12}
          echo "src_hash=$SHORT" >> "$GITHUB_OUTPUT"

      - name: app - build docker image
        working-directory: src
        env:
          IMAGE: "${{ vars.ACR_NAME }}.azurecr.io/app:${{ steps.srchash.outputs.src_hash }}"
        run: |
          echo "Building $IMAGE"
          docker build -t "$IMAGE" .

      - name: app - push to ACR
        run: |
          docker push "${{ vars.ACR_NAME }}.azurecr.io/app:${{ steps.srchash.outputs.src_hash }}"

  infra-deploy:
    environment: main
    needs: build-image
    name: 'Az Infra Deploy'
    runs-on: ubuntu-latest

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Azure using Federated Credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.UAMI_ID }}
          tenant-id: ${{ vars.TENANT_ID }}
          subscription-id: ${{ vars.SUB_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false
      - name: Create runtime tfbackend.conf
        working-directory: terraform
        run: |
            cat > tfbackend.conf <<EOF
            resource_group_name  = "${{ vars.RG_NAME }}"
            storage_account_name = "${{ vars.STORAGE_ACCOUNT_NAME }}"
            container_name       = "${{ vars.CONTAINER_NAME }}"
            key                  = "terraform.tfstate"
            EOF
        
      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend-config=tfbackend.conf 

      - name: Terraform Plan
        working-directory: terraform
        run: |
            terraform plan \
            -var "acr_name=${{ vars.ACR_NAME }}" \
            -var "rg_name=${{ vars.RG_NAME }}" \
            -var "project_name_no_dash=${{ vars.PROJECT_NAME_NODASH }}" \
            -var "image_name=app" \
            -var "image_tag=${{ needs.build-image.outputs.src_hash }}"

        # Terraform Apply
      - name: Terraform Apply
        working-directory: terraform
        run: |
            terraform apply -auto-approve \
            -var "acr_name=${{ vars.ACR_NAME }}" \
            -var "rg_name=${{ vars.RG_NAME }}" \
            -var "project_name_no_dash=${{ vars.PROJECT_NAME_NODASH }}" \
            -var "image_name=app" \
            -var "image_tag=${{ needs.build-image.outputs.src_hash }}"

      # - name: Capture Terraform outputs -> step outputs
      #   id: tfout
      #   working-directory: terraform
      #   run: |
      #     echo "aca_name=$(terraform output -raw container_app_name)" >> $GITHUB_OUTPUT
      #     echo "aca_region=$(terraform output -raw container_app_region)" >> $GITHUB_OUTPUT
      #     echo "aca_env_id=$(terraform output -raw container_app_environment_id)" >> $GITHUB_OUTPUT
      #     echo "acr_name=$(terraform output -raw container_registry_name)" >> $GITHUB_OUTPUT

      - name: Export outputs to environment (optional)
        working-directory: terraform
        run: |
          echo "ACA_NAME=$(terraform output -raw container_app_name)" >> $GITHUB_ENV
          echo "ACA_REGION=$(terraform output -raw container_app_region)" >> $GITHUB_ENV
          echo "ACA_ENV_ID=$(terraform output -raw container_app_environment_id)" >> $GITHUB_ENV
          echo "ACR_NAME=$(terraform output -raw container_registry_name)" >> $GITHUB_ENV

      - run:
          echo ${{ env.ACA_NAME }}
      
      - name: Update Container App (add extra TCP ports + new image)
        # env:
        #   RG: ${{ vars.RG_NAME }}
        #   ACA_NAME: ${{ vars.ACA_NAME }}
        #   ACA_ENV_NAME: ${{ vars.ACA_ENV_NAME }}
        #   ACR: ${{ vars.ACR_NAME }}
        #   IMAGE_TAG: ${{ needs.build-image.outputs.src_hash }}
        #   REGION: ${{ vars.REGION }}
        run: |
          set -e

          # Get the Container Apps Environment resource ID

          # Generate YAML with additional TCP ports 5433/5434 (ports must be unique across the env)
          cat > app.yaml <<'YAML'
          type: Microsoft.App/containerApps
          name: __ACA_NAME__
          location: __ACA_REGION__
          properties:
            environmentId: __ACA_ENV_ID__
            configuration:
              ingress:
                external: false
                transport: tcp
                targetPort: 5433
                exposedPort: 5433
                additionalPortMappings:
                  - targetPort: 5434
                    exposedPort: 5434
                    external: false
              registries:
                - server: __ACR_NAME__.azurecr.io
            template:
              revisionSuffix: v1
              containers:
                - name: nginx
                  image: __ACR_NAME__.azurecr.io/app:${{ steps.srchash.outputs.src_hash }}
                  resources:
                    cpu: 0.25
                    memory: 0.5Gi
          YAML

          # Substitute placeholders
          sed -i "s|__ACA_NAME__|$ACA_NAME|g" app.yaml
          sed -i "s|__ACA_REGION__|$ACA_REGION|g" app.yaml
          sed -i "s|__ACA_ENV_ID__|$ACA_ENV_ID|g" app.yaml
          sed -i "s|__ACR_NAME__|$ACR_NAME|g" app.yaml
          sed -i "s|__IMAGE_TAG__|$IMAGE_TAG|g" app.yaml

          echo "===== Rendered app.yaml ====="
          cat app.yaml

          # Update existing Container App with the new ports + image
          az containerapp update \
            --resource-group "${{ vars.RG_NAME }}" \
            --name "$ACA_NAME" \
            --yaml app.yaml

          echo "ACA updated. Ingress should now show ports 5433 and 5434."
